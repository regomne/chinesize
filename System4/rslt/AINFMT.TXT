System4.0 AIN format

0. はじめに

  これはSystem4.0のシナリオデ`タ *.ain についての分析メモです。

  目次
    1. 秃呕
    2. デ`タN
    3. 涫型(引数?返り)
    4. CODE部解h
     4.1 アセンブラコ`ド一E
     4.2 アセンブラコ`ド解h
     4.3 System4.0言Zとアセンブラコ`ド


1. 秃呕

  ainファイルはgな符号化を行っているのでまずそれを解きます。
  キ`は 0x5D3E3 で初期化した後、XOR、シフト等の演算をおこなっています。
  
2. デ`タN

  VERS: AIN バ`ジョン情 (0,1,4)
  CODE: シナリオ制御コ`ド
  FUNC: シナリオv数ラベルと引数
  GLOB: グロ`バル涫
  GSET: グロ`バル涫の初期
  STRT: 造体
  MSG0: ゲ`ムメッセ`ジ
  MAIN: mainv数番号
  MSGF: messagev数番号
  HLL0: DLL情
  SWI0: switch/case用デ`タ
  GVER: ゲ`ムのバ`ジョン
  SLBL: ? (VERS=1のみ)
  STR0: 文字列涫 (VERS>=1)
  FNAM: コンパイル前のシナリオファイル名 (VERS>=1)
  OJMP: onjumpv数番号 (VERS>=1)
  FNCT: v数型定x (VERS>=1)
  KEYC: ? (VERS>=4)


  char  ID1[4]; /* VERS */
  int32 rsv;    /* AINのバ`ジョン */

  char  ID2[4]; /* CODE */
  int32 len2;   /* CODE のLさ */

  char  ID3[4];   /* FUNC */
  int32 func_num; /* FUNC の数 */
    int32  func_adr;   /* v数のアドレス */
    char  *func_name;  /* v数名 (class@func, class@0, class@1) */
    int32  func_type;  /* 0: 通常v数, 1:シナリオv数 (VERS>=4のときのみ) */
    int32  func_ret0;  /* v数返の主型 */
    int32  func_ret1;  /* v数返の副型 */
    int32  func_argc1; /* 参数个数*/
    int32  func_argc2; /* 参数+局部变量の数 */
    int32  func_rsv;   /* ? (VERS>=4のときのみ) */
      char *func_argv_name; /* 引数の名前 */
      int32 func_argv_t0;   /* 引数の主型 */
      int32 func_argv_t1;   /* 引数の副型1 */
      int32 func_argv_t2;   /* 引数の副型2 */

 //  func_argc1 が 0 のrと, func_argc1=func_argc2はどう`うのか？

 // func_name == NULL (mainのコンストラクタ? (startup))
 // func_name == "\0x30"   (mainのデストラクタ? (exit))

  char  ID4[4];   /* GLOB */
  int32 glob_num; /* GLOB の数 */
    char *glob_name; /* 涫名 */
    int32 glob_t0;   /* 主型   */
    int32 glob_t1;   /* 副型１ */
    int32 glob_t2;   /* 副型２ */

  char  ID5[4];   /* GSET */
  int32 gset_len; /* GSETの数 */
    int32 gset_var; /* GLOB番号 */
    int32 gset_t0;  /* 主型 */
    {int32|char *} gset_value; /*  */

  char  ID6[4];   /* STRT */
  int32 strt_len; /* STRTの数 */
    char *strt_name;    /* 名前 */
    int32 strt_fncnst;  /* コンストラクタ FUNC番号 (なしのrは-1) */
    int32 strt_fndest;  /* デストラクタ   FUNC番号 (なしのrは-1) */
    int32 strt_numelem; /* 要素数 */
      char *strt_elem_name; /* 名前 */
      int32 strt_elem_t0;   /* 主型 */
      int32 strt_elem_t1;   /* 副型1 */
      int32 strt_elem_t2;   /* 副型2 */

  char  ID7[4];   /* MSG0 */
  int32 msg0_len; /* MSG0 の数 */
    char *msg0_name; /* メッセ`ジ文字列 */

  char  ID8[4];   /* MAIN */
  int32 main_len; /* メインv数番号 */

  char  ID9[4];    /* MSGF */
  int32 msgf_fno;  /* message v数番号 -1のrは未定x */

  char  ID10[4]; /* HLL0 */
  int32 hll_num; /* HLLの数 */
    char *hll_name;  /* HLLのファイル名 */
    int32 func_num;  /* HLL内部のv数の数 */
      char *func_name; /* v数名 */
      int32 func_ret;  /* 返のN */
      int32 func_argc; /* 引数の数 */
        char *argv_name;  /* 引数のN名 */
        int32 argv_t0;    /* 引数のN 
			   0: void
			   10: int
			   11: float
			   12: string (IString*)
                           13: struct (IMVStruct3 *)
                           14: array@int (IVMArray2 *)
                           18: intp/ref int (int *)
                           19: floatp/ref float (float *)
			   20: stringp/ref string (IString *)
			   21: ref xxxx (IVMSTruct3 *)
			   26: IMainSystem (IMainSystem *)
                           47: bool (bool)
 	                */

  char  ID11[4]; /* SWI0 */
  int32 swi_num; /* SWI0の数 */
    int32 rsv1;  /* 2=int/ 4=string */
    int32 rsv2;  /* defaultrのアドレス(-1のrはdefaultなし) */
    int32 num2;  /* caseの数 */
      int32 index; /* 事例式 */
      int32 data;  /* アドレス */

  char ID12[4]; /* GVER */
  int32 gver_id; /* ゲ`ムバ`ジョン */

  char ID13[4]; /* STR0 */
  int32 str0_num;
    char *srt0_str;

  char ID14[4]; /* FNAM */
  int32 fnam_num;
    char *fnam_str;

  char ID15[4]; /* OJMP */
  int32 ojmp_rsv0; /* onjumpv数番号 -1のrは未定x */

  char ID15[4]; /* FNCT */
  int32 fnct_bytes;  /* バイト数 */
  int32 fnct_num;    /* 数 */
    char *fnct_name;  /* v数名 */
    int32 fnct_ret0;  /* 返り主型 */
    int32 fnct_ret1;  /* 返り副型 */
    int32 fnct_argc0;  /* ??? */
    int32 fnct_argc1;  /* v数の引数の数 */
      char *name;         /* 引数の名前(ほとんどはダミ`) */
      int32 fnct_argv_t0; /* 引数主型  */
      int32 fnct_argv_t1; /* 引数副型1 */
      int32 fnct_argv_t2; /* 引数副型2 */

  char ID16[4]; /* SLBL */
  int32 slbl_num;
   char *slbl_name;
   int32 slbl_rsv0;

  char ID17[4]; /* KEYC */


3. 涫型(引数?返り)
  void:       0, -1, 0
  int:        10, -1, 0
  float:      11, -1, 0
  string:     12, -1, 0
  STRT:       13, STRT番号, 0
  array@int:  14, -1, 次元数
  array@float:  15, -1, 次元数
  array@string: 16, -1, 次元数
  array@STRT: 17, STRT番号, 次元数
  ref int:    18, -1, 0
  ref float:  19, -1, 0
  ref string: 20, -1, 0
  ref STRT:   21, STRT番号, 0
  ref array@int:     22, -1, 次元数
  ref array@float:   23, -1, 次元数
  ref array@string:  24, -1, 次元数
  ref array@STRT:    25, STRT番号, 次元数
  IMaingSystem:      26, -1, 0
  v数型:            27, -1, 0
  bool:              47, -1, 0


4. CODE部解h

4.1 アセンブラコ`ド一E

コ`ドは16bit、数は32ビット。

0x00,n: PUSH n
0x01: POP
0x02: REF
0x03: REFREF
0x04: PUSHGLOBALPAGE
0x05: PUSHLOCALPAGE
0x06: INV
0x07: NOT
0x08: COMPL
0x09: ADD
0x0A: SUB
0x0B: MUL
0x0C: DIV
0x0D: MOD
0x0E: AND
0x0F: OR
0x10: XOR
0x11: LSHIFT
0x12: RSHIFT
0x13: LT
0x14: GT
0x15: LTE
0x16: GTE
0x17: NOTE
0x18: EQUALE
0x19: ASSIGN
0x1A: PLUSA
0x1B: MINUSA
0x1C: MULA
0x1D: DIVA
0x1E: MODA
0x1F: ANDA
0x20: ORA
0x21: XORA
0x22: LSHIFTA
0x23: RSHIFTA
0x24: F_ASSIGN
0x25: F_PLUSA
0x26: F_MINUSA
0x27: F_MULA
0x28: F_DIVA
0x29: DUP2
0x2A: DUP_X2
0x2C,n: JUMP n
0x2D,n: IFZ n
0x2E,n: IFNZ n
0x2F: RETURN
0x30,n: CALLFUNC n
0x31: INC
0x32: DEC
0x33: FTOI
0x34: ITOF
0x35: F_INV
0x36: F_ADD
0x37: F_SUB
0x38: F_MUL
0x39: F_DIV
0x3A: F_LT
0x3B: F_GT
0x3C: F_LTE
0x3D: F_GTE
0x3E: F_NOTE
0x3F: F_EQUALE
0x40,n: F_PUSH n
0x41,n: S_PUSH n
0x42: S_POP
0x43: S_ADD
0x44: S_ASSIGN
0x45: S_PLUSA
0x46: S_REF
0x47: S_REFREF
0x48: S_NOTE
0x49: S_EQUALE
0x4A: SF_CREATE
0x4B: SF_CREATEPIXEL
0x4C: SF_CREATEALPHA
0x4D: SR_POP
0x4E: SR_ASSIGN
0x4F,n: SR_REF n
0x50: SR_REFREF
0x51: A_ALLOC
0x52: A_REALLOC
0x53: A_FREE
0x54: A_NUMOF
0x55: A_COPY
0x56: A_FILL
0x57: C_REF
0x58: C_ASSIGN
0x59,n: MES n
0x5A,m,n: CALLHLL m n
0x5B: PUSHSTRUCTPAGE
0x5C,n: CALLMETHOD n
0x5D,n: SH_GLOBALREF n
0x5E,n SH_LOCALREF n
0x5F,n SWITCH n
0x60,n STRSWITCH n
0x61,n <FUNC %d>
0x62,n <EOF %d>
0x63,n: CALLSYS n
0x64: SJUMP
0x65: CALLONJUMP
0x66: SWAP
0x67,n: SH_STRUCTREF n
0x68: S_LENGTH
0x69: S_LENGTHBYTE
0x6A: I_STRING
0x6B: CALLFUNC2
0x6C: CMD_DUP2_X1
0x6D: R_ASSIGN
0x6E: FT_ASSIGN
0x6F: ASSERT
0x70: S_LT
0x71: S_GT
0x72: S_LTE
0x73: S_GTE
0x74: S_LENGTH2
0x75: S_LENGTHBYTE2
0x76: NEW
0x77: DELETE
0x78: CHECKUDO
0x79: A_REF
0x7A: DUP
0x7B: DUP_U2
0x7C: SP_INC
0x7D: SP_DEC
0x7E,n <ENDFUNC>
0x7F: R_EQUALE
0x80: R_NOTE
0x81,m,n: SH_LOCALCREATE m,n
0x82 n: SH_LOCALDELETE n
0x83: STOI
0x84: A_PUSHBACK
0x85: A_POPBACK
0x86: S_EMPTY
0x87: A_EMPTY
0x88: A_ERASE
0x89: A_INSERT
0x8A,n: SH_LOCALINC n
0x8B,n: SH_LOCALDEC n
0x8C,m,n: SH_LOCALASSIGN m,n
0x8D: ITOB
0x8E: S_FIND
0x8F: S_GETPART
0x90: A_SORT
0x91: S_PUSHBACK
0x92: S_POPBACK
0x93: FTOS
0x94: S_MOD
0x95: S_PLUSA2
0x96: OBJSWAP
0x97: S_ERASE

0x98 n: SR_REF2
0x99: S_ERASE2
0x9A: S_PUSHBACK2
0X9B: S_POPBACK2
0X9C: ITOLI
0X9D: LI_ADD
0X9E: LI_SUB
0X9F: LI_MUL
0XA0: LI_DIV
0XA1: LI_MOD
0XA2: LI_ASSIGN
0XA3: LI_PLUSA
0XA4: LI_MINUSA
0XA5: LI_MULA
0xA6: LI_DIVA
0XA7: LI_MODA
0XA8: LI_ANDA
0XA9: LI_ORA
0XAA: LI_XORA
0XAB: LI_LSHIFTA
0XAC: LI_RSHIFTA
0XAD: LI_INC
0XAE: LI_DEC
0XAF: A_FIND
0XB0: A_REVERSE
0XB1: SH_SR_ASSIGN
0XB2 m n: SH_MEM_ASSIGN_LOCAL
0xB3 n: A_NUMOF_GLOB_1
0XB4 n: A_NUMOF_STRUCT_1
0XB5 m n: SH_MEM_ASSIGN_IMM
0xB6 n: SH_LOCALREFREF
0xB7 m n: SH_LOCAL_ASSIGN_SUM_IMM
0XB8 m n p: SH_IF_LOC_LT_IMM
0XB9 m n p: SH_IF_LOC_GE_IMM
0XBA m n: SH_LOCALREF_ASSIGN_MEM
0XBB m: PAGE_REF
0XBC m n: SH_GLOBAL_ASSIGN_LOCAL
0XBD m n: SH_STRUCTREF_GT_IMM
0xBE m n: SH_STRUCT_ASSIGN_LOCALREF_ITOB
0xBF m n: SH_LOCAL_ASSIGN_STRUCTREF
0XC0 m n p: SH_IF_STRUCTREF_NE_LOCALREF
0XC1 m n p: SH_IF_STRUCTREF_GT_IMM
0XC2 m n: SH_STRUCTREF_CALLMETHOD_NO_PARAM
0XC3 m n: SH_STRUCTREF2
0XC4 m n: SH_REF_STRUCTREF2
0XC5 m n p: SH_STRUCTREF3
0XC6 m n p: SH_STRUCTREF2_CALLMETHOD_NO_PARAM
0XC7 m n: SH_IF_STRUCTREF_Z
0XC8 m n: SH_IF_STRUCT_A_NOT_EMPTY
0XC9 m n p: SH_IF_LOC_GT_IMM
0XCA m n p: SH_IF_STRUCTREF_NE_IMM
0XCB m: THISCALLMETHOD_NOPARAM
0XCC m n p: SH_IF_LOC_NE_IMM
0XCD m n p: SH_IF_STRUCTREF_EQ_IMM
0XCE m n: SH_GLOBAL_ASSIGN_IMM
0XCF m n p: SH_LOCALSTRUCT_ASSIGN_IMM
0XD0 m n: SH_STRUCT_A_PUSHBACK_LOCAL_STRUCT
0XD1 m n: SH_GLOBAL_A_PUSHBACK_LOCAL_STRUCT
0XD2 m n: SH_LOCAL_A_PUSHBACK_LOCAL_STRUCT
0XD3 m n: SH_IF_SREF_NE_STR0
0XD4: SH_S_ASSIGN_REF
0XD5: SH_A_FIND_SREF
0XD6: SH_SREF_EMPTY
0XD7 m n: SH_STRUCTSREF_EQ_LOCALSREF
0XD8 m n: SH_LOCALSREF_EQ_STR0
0XD9 m n: SH_STRUCTSREF_NE_LOCALSREF
0XDA m n: SH_LOCALSREF_NE_STR0
0XDB m n: SH_STRUCT_SR_REF
0XDC n: SH_STRUCT_S_REF
0XDD n: S_REF2
0XDE m n p: SH_REF_LOCAL_ASSIGN_STRUCTREF2
0XDF m: SH_GLOBAL_S_REF
0XE0 m: SH_LOCAL_S_REF
0XE1 m n: SH_LOCALREF_SASSIGN_LOCALSREF
0XE2 m n: SH_LOCAL_APUSHBACK_LOCALSREF
0XE3: SH_S_ASSIGN_CALLSYS19
0XE4 m: SH_S_ASSIGN_STR0
0XE5 m: SH_SASSIGN_LOCALSREF
0XE6 m n: SH_STRUCTREF_SASSIGN_LOCALSREF
0XE7 m: SH_LOCALSREF_EMPTY
0XE8 m n: SH_GLOBAL_APUSHBACK_LOCALSREF
0XE9 m n: SH_STRUCT_APUSHBACK_LOCALSREF
0XEA m: SH_STRUCTSREF_EMPTY
0XEB m: SH_GLOBALSREF_EMPTY
0XEC m: SH_SASSIGN_STRUCTSREF
0XED m: SH_SASSIGN_GLOBALSREF
0XEE m: SH_STRUCTSREF_NE_STR0  ??
0XEF m n: SH_GLOBALSREF_NE_STR0
0XF0 m n p: SH_LOC_LT_IMM_OR_LOC_GE_IMM

4.2 アセンブラコ`ド解h

JAMコ`ド: PUSH n
code: 0x00, n(32)
C能: int型数 n をスタックにeむ

JAMコ`ド: POP
code: 0x01
C能: スタックから32ビットを取り出す

JAMコ`ド: REF
code: 0x02
C能: スタックにある涫をポインタとして参照先のを取り出す (???)

JAMコ`ド: REFREF
code: 0x03
C能: (???)

JAMコ`ド: PUSHGLOBALPAGE
code: 0x04
C能: グロ`バル涫を示すペ`ジ番号をスタックにeむ。グロ`バル涫の
プレフィックスとして使用し、直後に涫番号をPUSH n: でeむ。

JAMコ`ド: PUSHLOCALPAGE
code: 0x05
C能: ロ`カル涫を示すペ`ジ番号をスタックにeむ。ロ`カル涫の
プレフィックスとして使用し、直後に涫番号をPUSH n: でeむ。

JAMコ`ド: INV
code: 0x06
C能: int型号演算(-)
      スタックにある数を取り出し、の数にQしてY果をスタックにeむ。

JAMコ`ド: NOT
code: 0x07
C能: 否定演算(!)
      スタックにある数を取り出し、否定演算を行いY果をスタックにeむ。

JAMコ`ド: COMPL
code: 0x08
C能: a数演算(~)
      スタックにある数を取り出し、否定演算を行いY果をスタックにeむ。

JAMコ`ド: ADD
code: 0x09
C能: int型加算 (+)
      スタックにある数を２つ取り出し、int型として加算しY果をスタックにeむ。
      a = pop, b = pop, c = b + a, push(c)

JAMコ`ド: SUB
code: 0x0A
C能: int型p算 (-)
      スタックにある数を２つ取り出し、int型としてp算しY果をスタックにeむ。
      最初に取り出す方が引く数。
      a = pop, b = pop, c = b - a, push(c)

JAMコ`ド: MUL
code: 0x0B
C能: int型\算 (*)
      スタックにある数を２つ取り出し、int型として\算しY果をスタックにeむ。
      a = pop, b = pop, c = b * a, push(c)

JAMコ`ド: DIV
code: 0x0C
C能: int型除算 (/)
      スタックにある数を２つ取り出し、int型として除算しY果をスタックにeむ。
      最初に取り出す方が割る数。
      a = pop, b = pop, c = b / a, push(c)

JAMコ`ド: MOD
code: 0x0D
C能: int型余 (%)
      スタックにある数を２つ取り出し、int型として余を算しY果をスタック
      にeむ。最初に取り出す方が割る数。
      a = pop, b = pop, c = b % a, push(c)

JAMコ`ド: AND
code: 0x0E
C能: ビットe (&)
      スタックにある数を２つ取り出し、ビットeを算しY果をスタックにeむ。
      a = pop, b = pop, c = b & a, push(c)

JAMコ`ド: OR 
code: 0x0F
C能: ビットe (|)
      スタックにある数を２つ取り出し、ビット和を算しY果をスタックにeむ。
      a = pop, b = pop, c = b | a, push(c)

JAMコ`ド: XOR
code: 0x10
C能: ビット差 (^)
      スタックにある数を２つ取り出し、ビット差(排他理和)を算しY果を
      スタックにeむ。
      a = pop, b = pop, c = b ^ a, push(c)

JAMコ`ド: LSHIFT
code: 0x11
C能: 左シフト (<<)
      スタックにある数を２つ取り出し、後から取り出した数を、始めに取り出
      した数のぶんだけ左シフト算しY果をスタックにeむ。
      a = pop, b = pop, c = b << a, push(c)

JAMコ`ド: RSHIFT
code: 0x12
C能: 右シフト (>>)
      スタックにある数を２つ取り出し、後から取り出した数を、始めに取り出
      した数のぶんだけ右シフト算しY果をスタックにeむ。
      a = pop, b = pop, c = b >> a, push(c)

JAMコ`ド: LT
code: 0x13
C能: 小なり(int型) (<)
      スタックにある数を２つ取り出し、後から取り出した数(b)が始めに取り出
      した数(a)よりも小さい龊1、大きいか等しい龊0をスタックにeむ。
      a = pop, b = pop, push(b < a ? 1 : 0)

JAMコ`ド: GT
code: 0x14
C能: 大なり(int型) (<)
      スタックにある数を２つ取り出し、後から取り出した数(b)が始めに取り出
      した数(a)よりも大きい龊1、小さいか等しい龊0をスタックにeむ。
      a = pop, b = pop, push(b > a ? 1 : 0)

JAMコ`ド: LTE
code: 0x15
C能: 以下 (int型) (<=)
      スタックにある数を２つ取り出し、後から取り出した数(b)が始めに取り出
      した数(a)以上の龊1、小さい龊0をスタックにeむ。
      a = pop, b = pop, push(b <= a ? 1 : 0)

JAMコ`ド: GTE
code: 0x16
C能: 以下 (int型) (>=)
      スタックにある数を２つ取り出し、後から取り出した数(b)が始めに取り出
      した数(a)以下の龊1、大きい龊0をスタックにeむ。
      a = pop, b = pop, push(b >= a ? 1 : 0)

JAMコ`ド: NOTE
code: 0x17
C能: 非等 (int型) (!=)
      スタックにある数を２つ取り出し、２つが等しくない龊1、等しい龊0を
      スタックにeむ。
      a = pop, b = pop, push(b != a ? 1 : 0)

JAMコ`ド: EQUALE
code: 0x18
C能: 等 (int型) (!=)
      スタックにある数を２つ取り出し、２つが等しい龊1、等しくない龊0を
      スタックにeむ。
      a = pop, b = pop, push(b == a ? 1 : 0)

JAMコ`ド: ASSIGN
code: 0x19
C能: 涫にint型数を代入 (=)
      スタックにある数と涫を取り出し、数をint型として涫に代入。また
      演算Y果をスタックにeむ。
      a = pop; b = popvar, b = a, push(a)

JAMコ`ド: PLUSA
code: 0x1A
C能: 加算代入 (int型) (+=)
      スタックにある数と涫を取り出し、数をint型として涫に加算代入。
      また演算Y果をスタックにeむ。
      a = pop; b = popvar, b = b + a, push(b)

JAMコ`ド: MINUSA
code: 0x1B
C能: p算代入 (int型) (-=)
      スタックにある数と涫を取り出し、数をint型として数にp算代入。
      また演算Y果をスタックにeむ。
      a = pop; b = popvar, b = b - a, push(b)


JAMコ`ド: MULA
code: 0x1C
C能: \算代入 (int型) (*=)
      スタックにある数と涫を取り出し、数をint型として涫に\算代入。
      また演算Y果をスタックにeむ。
      a = pop; b = popvar, b = b * a, push(b)

JAMコ`ド: DIVA
code: 0x1D
C能: 除算代入 (int型) (/=)
      スタックにある数と涫を取り出し、数をint型として涫に除算代入。
      また演算Y果をスタックにeむ。
      a = pop; b = popvar, b = b / a, push(b)

JAMコ`ド: MODA
code: 0x1E
C能: 余代入 (int型) (%=)
      スタックにある数と涫を取り出し、涫に数を余代入。また、演算Y果
      をスタックにeむ。
      a = pop; b = popvar, b = b % a, push(b)

JAMコ`ド: ANDA
code: 0x1F
C能: ビットe代入 (&=)
      スタックにある数と涫を取り出し、涫のと数のビットeを算し、
      Y果を涫に代入。また、演算Y果をスタックにeむ。
      a = pop; b = popvar, b = b & a, push(b)

JAMコ`ド: ORA
code: 0x20
C能: ビット和代入 (|=)
      スタックにある数と涫を取り出し、涫のと数のビット和を算し、
      Y果を涫に代入。また、演算Y果をスタックにeむ。
      a = pop; b = popvar, b = b | a, push(b)

JAMコ`ド: XORA
code: 0x21
C能: ビット差代入 (^=)
      スタックにある数と涫を取り出し、涫のと数のビット差を算し、
      Y果を涫に代入。また、演算Y果をスタックにeむ。
      a = pop; b = popvar, b = b ^ a, push(b)

JAMコ`ド: LSHIFTA
code: 0x22
C能: 左シフト代入 (<<=)
      スタックにある数と涫を取り出し、涫のを数の分だけ左シフトし、
      Y果を涫に代入。また、演算Y果をスタックにeむ。
      a = pop; b = popvar, b = b << a, push(b)

JAMコ`ド: RSHIFTA
code: 0x23
C能: 右シフト代入 (<<=)
      スタックにある数と涫を取り出し、涫のを数の分だけ右シフトし、
      Y果を涫に代入。また、演算Y果をスタックにeむ。
      a = pop; b = popvar, b = b >> a, push(b)

JAMコ`ド: F_ASSIGN
code: 0x24
C能: 涫にfloat型数を代入 (=)
      スタックにある数と涫を取り出し、数をfloat型として涫に代入。また
      演算Y果をスタックにeむ。
      a = pop; b = popvar, b = a, push(a)

JAMコ`ド: F_PLUSA
code: 0x25
C能: 加算代入 (float型) (+=)
      スタックにある数と涫を取り出し、数をfloat型として涫に加算代入。
      また演算Y果をスタックにeむ。
      a = pop; b = popvar, b = b + a, push(b)

JAMコ`ド: F_MINUSA
code: 0x26
C能: p算代入 (float型) (-=)
      スタックにある数と涫を取り出し、数をfloat型として涫にp算代入。
      また演算Y果をスタックにeむ。
      a = pop; b = popvar, b = b - a, push(b)

JAMコ`ド: F_MULA
code: 0x27
C能: \算代入 (float型) (*=)
      スタックにある数と涫を取り出し、数をfloat型として涫に\算代入。
      また演算Y果をスタックにeむ。
      a = pop; b = popvar, b = b * a, push(b)

JAMコ`ド: F_DIVA
code: 0x28
C能: 除算代入 (float型) (/=)
      スタックにある数と涫を取り出し、数をfloat型として涫に除算代入。
      また演算Y果をスタックにeむ。
      a = pop; b = popvar, b = b / a, push(b)

JAMコ`ド: DUP2
code: 0x29
C能: スタックにある涫を}uしてスタックにeむ (???)

JAMコ`ド: DUP_X2
code: 0x2A
C能: (???)

JAMコ`ド: JUMP n
code: 0x2C, n
C能: o条件ジャンプ
      o条件で指定のアドレス n にジャンプする。

JAMコ`ド: IFZ n
code: 0x2D, n
C能: 真条件ジャンプ
      スタックからを取り出し、真の龊(0以外のr)に指定のアドレス n に
      ジャンプする。
      a = pop, if (a) goto n;

JAMコ`ド: IFNZ n
code: 0x2E, n
C能: 翁跫ジャンプ
      スタックからを取り出し、韦龊(0のr)に指定のアドレス n に
      ジャンプする。
      a = pop, if (a==0) goto n;

JAMコ`ド: RETURN
code: 0x2F
C能: v数リタ`ン
      スタックにが残っていれば、それをv数のとして呼び出し元に返し、
      v数からする。v数からするときに次のI理を行う。
      1) ロ`カル涫の破
      2) ...

JAMコ`ド: CALLFUNC n
code: 0x30, n
C能: v数呼び出し
      番号n番のv数を呼び出す。v数のアドレスや引数の数とNはFUNCタグのI域
      に述されている。v数の引数はスタックにeまれている。

JAMコ`ド: INC
code: 0x31
C能: 分(++)
      スタックにeまれている数または涫を取り出して１やし、Y果を
      スタックにeむ。

JAMコ`ド: DEC
code: 0x32
C能: p分(--)
      スタックにeまれている数または涫を取り出して１pらし、Y果を
      スタックにeむ。

JAMコ`ド: FTOI
code: 0x33
C能: float->intQ
      スタックにeまれている数を取り出してfloat型からint型にQし、
      Y果をスタックにeむ。

JAMコ`ド: ITOF
code: 0x34
C能: int->floatQ
      スタックにeまれている数を取り出してint型からfloat型にQし、
      Y果をスタックにeむ。

JAMコ`ド: F_INV
code: 0x35
C能: float型号演算 (-)
      スタックにある数を取り出し、の数にQして再度スタックにeむ。

JAMコ`ド: F_ADD
code: 0x36
C能: float型加算 (+)
      スタックにある数を２つ取り出し、float型として加算しY果をスタック
      にeむ。
      a = pop, b = pop, c = b + a, push(c)

JAMコ`ド: F_SUB
code: 0x37
C能: float型p算 (-)
      スタックにある数を２つ取り出し、float型としてp算しY果をスタック
      にeむ。最初に取り出す方が引く数。
      a = pop, b = pop, c = b - a, push(c)

JAMコ`ド: F_MUL
code: 0x38
C能: float型\算 (*)
      スタックにある数を２つ取り出し、float型として\算しY果をスタック
      にeむ。
      a = pop, b = pop, c = b * a, push(c)

JAMコ`ド: F_DIV
code: 0x39
C能: float型除算 (/)
      スタックにある数を２つ取り出し、float型として除算しY果をスタック
      にeむ。最初に取り出す方が割る数。
      a = pop, b = pop, c = b / a, push(c)

JAMコ`ド: F_LT
code: 0x3A
C能: 小なり(float型) (<)
      スタックにある数を２つ取り出し、後から取り出した数(b)が始めに取り出
      した数(a)よりも小さい龊1、大きいか等しい龊0をスタックにeむ。
      a = pop, b = pop, push(b < a ? 1 : 0)


JAMコ`ド: F_GT
code: 0x3B
C能: 大なり(float型) (<)
      スタックにある数を２つ取り出し、後から取り出した数(b)が始めに取り出
      した数(a)よりも大きい龊1、小さいか等しい龊0をスタックにeむ。
      a = pop, b = pop, push(b > a ? 1 : 0)

JAMコ`ド: F_LTE
code: 0x3C
C能: 以下 (float型) (<=)
      スタックにある数を２つ取り出し、後から取り出した数(b)が始めに取り出
      した数(a)以上の龊1、小さい龊0をスタックにeむ。
      a = pop, b = pop, push(b <= a ? 1 : 0)

JAMコ`ド: F_GTE
code: 0x3D
C能: 以下 (float型) (>=)
      スタックにある数を２つ取り出し、後から取り出した数(b)が始めに取り出
      した数(a)以下の龊1、大きい龊0をスタックにeむ。
      a = pop, b = pop, push(b >= a ? 1 : 0)

JAMコ`ド: F_NOTE
code: 0x3E
C能: 非等 (float型) (!=)
      スタックにある数を２つ取り出し、２つが等しくない龊1、等しい龊0を
      スタックにeむ。
      a = pop, b = pop, push(b != a ? 1 : 0)

JAMコ`ド: F_EQUALE
code: 0x3F
C能: 等 (float型) (!=)
      スタックにある数を２つ取り出し、２つが等しい龊1、等しくない龊0を
      スタックにeむ。
      a = pop, b = pop, push(b == a ? 1 : 0)

JAMコ`ド: F_PUSH n
code: 0x40, n(32)
C能: float型数 n をスタックにeむ

JAMコ`ド: S_PUSH n
code: 0x41, n(32)
C能: string番号 n をスタックにeむ

JAMコ`ド: S_POP
code: 0x42
C能: スタックからstringオブジェクトを取り出す。

JAMコ`ド: S_ADD
code: 0x43
C能: スタックから２つのstringオブジェクトを取り出し、Y合してY果をスタックに
      eむ。

JAMコ`ド: S_ASSIGN
code: 0x44
C能: スタックから 涫とstringオブジェクトを取り出し、涫に文字列を代入して
      Y果をスタックにeむ。

JAMコ`ド: S_PLUSA
code: 0x45
C能: 旧文字列Y合 (+) -> F在は S_PLUSA2 コ`ドに涓されている。

JAMコ`ド: S_REF
code: 0x46
C能: スタックにある涫をポインタとして参照先のstringオブジェクトを取り出す。
      (???)

JAMコ`ド: S_REFRRF
code: 0x47
C能: (???)

JAMコ`ド: S_NOTE
code: 0x48
C能: 非等 (string型)(!=)
      スタックにある文字列を２つ取り出し、２つが等しくない龊1、等しい龊0を
      スタックにeむ。
      a = pop, b = pop, push(strcmp(b,a) ? 1 : 0)

JAMコ`ド: S_EQUALE
code: 0x49
C能: 等 (string型)(==)
      スタックにある文字列を２つ取り出し、２つが等しい龊1、等しくない龊0を
      スタックにeむ。
      a = pop, b = pop, push(strcmp(b,a) == 0 ? 1 : 0)

JAMコ`ド: SR_POP
code: 0x4D
C能: スタックから造体オブジェクトを取り出す。

JAMコ`ド: SR_ASSIGN
code: 0x4E
C能: スタックから涫と造体オブジェクトを取り出し、涫に造体を代入。

JAMコ`ド: SR_REF, n
code: 0x4F, n
C能: スタックから涫を取り出し、造体の番号 n を参照するように指定。

JAMコ`ド: SR_REFREF
code: 0x50
C能: (???)

JAMコ`ド: A_ALLOC
code: 0x51
C能: 配列オブジェクトのメモリ_保 (array::Alloc)
      涫と次元数と要素数をスタックから取り出し、涫に配列オブジェクトを
      を割り当て。
      N = pop, b1 = pop, b2 = pop, ... , bN=pop, var = popvar
      N: 次元数, b1～bN: 各次元の要素数, var: 割り当てる涫

JAMコ`ド: A_REALLOC
code: 0x52
C能: 配列オブジェクトの再メモリ_保 (array::Realloc)
      涫と次元数と要素数をスタックから取り出し、涫に配列オブジェクトを
      を再割り当て。
      N = pop, b1 = pop, b2 = pop, ... , bN=pop, var = popvar
      N: 次元数, b1～bN: 各次元の要素数, var: 割り当てる涫

JAMコ`ド: A_FREE
code: 0x53
C能: 配列オブジェクトのメモリ_放 (array::Free)
      涫をスタックから取り出して、割り当てられた配列を_放。

JAMコ`ド: A_NUMOF
code: 0x54
C能: 配列の指定の次元の要素数の取得 (array::Numof)
      涫と要素数を取得する次元の番号をスタックから取り出し、要素数をスタック
      にeむ。

JAMコ`ド: A_COPY
code: 0x55
C能: 配列のコピ` (array::Copy)
      涫とコピ`元、コピ`先等をスタックから取り出してコピ`をg行後、
      gHにコピ`した数をスタックにeむ。
      var1.Copy(i,var2,j,num);
      num = pop, j = pop, var2 = popvar, i = pop, var1 = popvar;

JAMコ`ド: A_FILL
code: 0x56
C能: 配列のTりつぶし (array::Fill)
      涫と送先インデックス、Tりつぶす数と要素をスタックから取り出して
      Tりつぶしをg行後、gHにTりつぶした数をスタックにeむ。
      var1.Fill(index,val,num);
      num = pop, val = pop, index = pop, var1 = popvar;

JAMコ`ド: C_REF
code: 0x57
C能: char定数の参照 
      文字列をchar型の配列としてたときの index参照 (???)

JAMコ`ド: C_ASSIGN
code: 0x58
C能: char定数の代入 
      文字列をchar型の配列としてたときの代入 (???)

JAMコ`ド: MES n
code: 0x59, n
C能: メッセ`ジ表示。n: メッセ`ジ番号。
      メッセ`ジ番号は MSG0 タグ内の番号。

JAMコ`ド: CALLHLL m n
code: 0x5A, m, n
C能: HLL呼び出し。m: HLL番号, n:HLL内v数番号。
      引数はスタックからに取り出す。呼び出し後、HLLの返りをスタックにeむ。

JAMコ`ド: PUSHSTRUCTPAGE
code: 0x5B
C能: 造体を示すペ`ジ番号をスタックにeむ。造体の涫をコンストラクタ内で
       初期化するrに使用。(????)

JAMコ`ド: CALLMETHOD n
code: 0x5C, n
C能: 造体/クラスのv数呼び出し、 n: FUNCタグ内の番号

JAMコ`ド: SH_GLOBALREF n
code: 0x5D, n
C能: グロ`バル涫の涫の中身を取り出してスタックにeむ。

JAMコ`ド: SH_LOCALREF n
code: 0x5E, n
C能: ロ`カル涫の涫の中身を取り出してスタックにeむ。

JAMコ`ド: SWITCH n
code: 0x5F, n
C能: int型 switch/case g行。n: SWI0の番号

JAMコ`ド: STRSWITCH n
code: 0x60, n
C能: string型 switch/case g行。n: SWI0の番号

JAMコ`ド: <FUNC n>
code: 0x61, n
C能: v数_始宣言。n: v数(FUNC)番号

JAMコ`ド: <EOF n>
code: 0x62, n
C能: ファイルのKわり。n: ファイル番号

JAMコ`ド: CALLSYS n
code: 0x63, n
C能: systemv数呼び出し。n: Systemv数番号

JAMコ`ド: SJUMP
code: 0x64
C能: シナリオv数呼び出し(jump シナリオv数) (???)

JAMコ`ド: CALLONJUMP
code: 0x65
C能: SJUMP前に呼ばれる (???)

JAMコ`ド: SWAP
code: 0x66
C能: v数呼び出しrに使用 (???)

JAMコ`ド: SH_STRUCTREF n
code: 0x67, n
C能: n番のSTRT型として造体を参照する

JAMコ`ド: S_LENGTH
code: 0x68
C能: 文字列のLさを取得(string::Length()) 
      stringオブジェクトをスタックから取り出して、文字列のLさをスタックに
      eむ。

JAMコ`ド: S_LENGTHBYTE
code: 0x69
C能: 文字列のLさを取得(string::LengthByte()) 
      stringオブジェクトをスタックから取り出して、文字列のLさをスタックに
      eむ。

JAMコ`ド: I_STRING
code: 0x6A
C能: int型数->文字列Q (var.String())
      スタックから数を取り出して、文字列にQし、stringオブジェクトを
      スタックにeむ。

JAMコ`ド: CALLFUNC2
code: 0x6B
C能: v数型オブジェクトの呼び出し

JAMコ`ド: CMD_DUP2_X1
code: 0x6C
C能: (???)

JAMコ`ド: R_ASSIGN
code: 0x6D
C能: 参照代入 (???)

JAMコ`ド: FT_ASSIGN
code: 0x6E
C能: v数型代入 (???)

JAMコ`ド: ASSERT
code: 0x6F
C能: assert (???)

JAMコ`ド: S_LT
code: 0x70
C能: 小なり(string型) (<)
      スタックにある文字列を２つ取り出し、後から取り出した文字列(b)が始めに
      取り出した文字列(a)よりも辞的に小さい龊1、大きいか等しい龊0を
      スタックにeむ。
      a = pop, b = pop, push(b < a ? 1 : 0)

JAMコ`ド: S_GT
code: 0x71
C能: 大なり(string型) (<)
      スタックにある文字列を２つ取り出し、後から取り出した文字列(b)が始めに
      取り出した文字列(a)よりも辞的に大きい龊1、小さいか等しい龊0を
      スタックにeむ。
      a = pop, b = pop, push(b > a ? 1 : 0)

JAMコ`ド: S_LTE
code: 0x72
C能: 以下 (string型) (<=)
      スタックにある文字列を２つ取り出し、後から取り出した文字列(b)が始めに
      取り出した文字列(a)以上の龊1、小さい龊0をスタックにeむ。
      a = pop, b = pop, push(b <= a ? 1 : 0)

JAMコ`ド: S_GTE
code: 0x73
C能: 以下 (string型) (>=)
      スタックにある文字列を２つ取り出し、後から取り出した文字列(b)が始めに
      取り出した文字列(a)以下の龊1、大きい龊0をスタックにeむ。
      a = pop, b = pop, push(b >= a ? 1 : 0)

JAMコ`ド: S_LENGTH2
code: 0x74
C能: (???)
      nTextLength += mm.GetString(i).Length();

JAMコ`ド: DELETE
code: 0x77
C能: (???) ref

JAMコ`ド: ?????
code: 0x79
C能: (???)

JAMコ`ド: ?????
code: 0x7A
C能: (???)

JAMコ`ド: DUP_U2
code: 0x7B
C能: (???) ref

JAMコ`ド: SP_INC
code: 0x7C
C能: (???) ref

JAMコ`ド: SP_DEC
code: 0x7D
C能: (???)

JAMコ`ド: R_EQUALE
code: 0x7F
C能: 参照先の同一性チェック(===)
      同一のr 1, 同一出ないとき 0

JAMコ`ド: R_NOTE
code: 0x80
C能: 参照先の同一性チェック(!==)
      同一のr 1, 同一出ないとき 0

JAMコ`ド: SH_LOCALCREATE m, n
code: 0x81, m, n
C能: 造体を涫にバインド
      m: 涫番号, n: 造体番号

JAMコ`ド: SH_LOCALDELETE n
code: 0x82, n
C能: 涫にバインドした造体情螭蛳鞒
      n: 涫番号

JAMコ`ド: STOI
code: 0x83
C能: stringをintにQ (string::Int())
      スタックから文字列を取り出し、int型数にQし、Y果をスタックにeむ。

JAMコ`ド: A_PUSHBACK
code: 0x84
C能: 配列の最後にを追加 (array::PushBack())
      スタックから(a)と配列涫を取り出し、配列涫の最後にa追加する。
      a = pop, var = popvar, var.pushback(a)

JAMコ`ド: A_POPBACK
code: 0x85
C能: 配列の再後尾から削除 (array::PopBack())
      スタックから配列涫を取り出し、再後尾を削除。

JAMコ`ド: S_EMPTY
code: 0x86
C能: 文字列が空なら1、そうでないなら0を返す(string::Empty())

JAMコ`ド: A_EMPTY
code: 0x87
C能: 配列が空なら1、そうでないなら0を返す(array::Empty())

JAMコ`ド: A_ERASE
code: 0x88
C能: 指定されたインデックスのオブジェクトを削除。(array::Erase())

JAMコ`ド: A_INSERT
code: 0x89
C能: 指定されたインデックスにオブジェクトを啡搿(array::Insert())

JAMコ`ド: SH_LOCALINC n
code: 0x8A, n
C能: 後置分演算子 (++)
      nを涫番号として１加算する。

JAMコ`ド: SH_LOCALDEC n
code: 0x8B, n
C能: 後置p分演算子 (--)
      nを涫番号として１p算する。

JAMコ`ド: SH_LOCALASSIGN m, n
code: 0x8C, m, n
C能: int型ロ`カル涫の宣言と代入
      m: 涫番号, n:

JAMコ`ド: ITOB
code: 0x8D
C能: int型からbool型にQ。

JAMコ`ド: S_FIND
code: 0x8E
C能: 文字列からszKeyがあるか{べる。(string::Find())

JAMコ`ド: S_GETPART
code: 0x8F
C能: 文字列の一部を取り出す。(string::GetPart())

JAMコ`ド: A_SORT
code: 0x90
C能: 配列のソ`ト。(array::GetPart())

JAMコ`ド: S_PUSHBACK
code: 0x91
C能: 文字列の最後尾にnCharaの文字を追加。(string::PushBackt())

JAMコ`ド: S_POPBACK
code: 0x92
C能: 文字列の最後尾の文字を削除。(string::PopBackt())

JAMコ`ド: FTOS
code: 0x93
C能: floatをstringにQ (float::String())

JAMコ`ド: S_MOD
code: 0x94
C能: floatをstringにQ (float::String())

JAMコ`ド: S_PLUSA2
code: 0x95
C能: 文字列BY

JAMコ`ド: OBJSWAP
code: 0x96
C能: オブジェクト同士の交Q

JAMコ`ド: S_ERASE
code: 0x97
C能: 文字列の指定位置の文字を削除 (string::Erase())



4.3 System4.0言Zとアセンブラコ`ド

マニュアルの述に生成されるアセンブラコ`ドを述
涫は基本的にロ`カル涫。()内はビット数。

涫オブジェクト
int var: 0x8c(16),var(32),num(32) // int var=整数も同じ
float var: 5(16),0(16),var(32),0x40(16),g数(32),0x24(16),1(16) // int var=g数も同じ
bool var: 0x8c(16),var(32),整数(32) // int varと同じ
String var: 0x5e(16),var(32),0x41(16),strnum(32),0x44(16),0x42(16)
  // strnumは文字列定数が格{されたインデクス、0の龊悉NULL)

配列オブジェクト
array@int var: 5(16),0(16),var(32),0x53(16) // var.Free()と同じ
array@int@num var: 5(16),0(16),var(32),0x53(16) 
var.Alloc(num): 5(16),0(16),var(32),0(16),num(32),0(16),次元数=1(32),0x51 // array@int var[num)と同じ
var.Alloc(i,j): 5(16),0(16),var(32),0(16),i(32),0(16),j(32),0,次元数=2(32),0x51
var[i]=j: 0x5e,var(32),0(16),i(32),0(16),j(32),0x19(16),1(16)
var[i][j]=k: 0x5e,var(32),0(16),i(32),2(16),0(16),j(32),0(16),k(32),0x19(16),1(16)
var[i][j][k]=l: 0x5e,var(32),0(16),i(32),2(16),0(16),j(32),2(2),0(16),k(32),0(16),l(32),0x19(16),1(16)

参照オブジェクト
 宣言: 
   ref int rVar:     5,0,rVar,0x63,3(32),1,0x29,3,1,0x77,0x63,4(32),1,0,-1(32),0,0,0,       0x6D,1,1
   ref int rVar=var: 5,0,rVar,0x63,3,    1,0x29,3,1,0x77,0x63,4,    1,0x29,5,0,var,0x63,3,1,0x6D,1,1,2,0x7C,0x63,4,1:
 参照先の涓
   rVar<-var:        5,0,rVar,0x63,3,    1,0x29,3,1,0x77,                  5,0,var,0x7B,0x7C,0x6D,1,1,0x63,4,1

 参照先の同一性チェック
   if (rVar1 === rVar2): // 5,0,rVar1,3,5,0,rVar2,3,0x7F,0x2D,adr
   if (rVar1 !== rVar2): // 5,0,rVar1,3,5,0,rVar2,3,0x80,0x2D,adr

 アクセス:
   rVar = var: 5,0,rVar,3,0x5E,var,0x19,1
   rVar = val: 5,0,rVar,3,0,val,0x19,1

定数オブジェクト
  コンパイルrにuされるのでコ`ドには出Fしない

造体?クラス
  造体宣言:  STRTタグ部分に格{される。
  造体オブジェクト宣言:
    0x82,varno: 造体用涫宣言
    0x81,varno,strtno: 涫を造体にマップ
      struct sVar; 0x82,sVar,0x81,sVar,STRT番号
  造体オブジェクト使用
    造体オブジェクト番号の後に涫のインデックスを追加
      sVar.member=val; 0x5E(16),sVar,0(16),member(32),0(16),val(32),0x19,1
  造体オブジェクト同士のコピ`
    0x4F,strno;
	sVar1=sVar2; 0x5E,sVar1,5,0,sVar2,0x4F(16),STRTnum,0,STRTnum,0x4E,0x4D



アクセス指定
  TODO

v数
  v数定x
    0x61(16),funcno(32),文,(りの式),0x2F(16),0(16),0(16),0x2F(16),0x7E(16),funcno(32)
    v数引数->ロ`カル涫のに涫番号が割り当てられる

メソッド
  var = sVar.method(arg1,arg2):
  5(16),0(16),varno(32),0x5E(16),sVar(32),0(16),arg1(32),0(16),arg2(32),0x5C(16),methodno(32),0x19(16),1(16)

シナリオv数
  jump シナリオv数: 0x41,strno(32),0x65(16),0x64(16)

コンストラクタ
  hoge@0 というv数が宣言される

デストラクタ
  hoge@1 というv数が宣言される

???
  hoge@2 というv数が宣言される

デフォルト引数
  コンパイラがエンコ`ドrに、デフォルト引数をv数呼び出しの引数のとして追加

v数型
  呼び出しr
    0x5E,var,0,arg1,0x66,0,arg2,0x66,0(16),fnctno,0x6B,1

  文字列仕鞔入
   ftVar = "function"
   5,0,funcno,0x41,strno,0(16),0(32),0x6E,0x42

ラベル
事前定xマクロ
this参照オブジェクト
NULLオブジェクト
引数加v数マクロ
 TODO


intオブジェクトv数
str=var.String(): 0x5E(16),str(32),0x5E(16),var(32),0x6A(16),0x44(16),0x42(16)

floatオブジェクトv数
str=fVar.String(): 0x5E(16),str(32),0x5E(16),fVar(32),0(16),-1(32),0x93(16),0x44(16),0x42(16)
str=fVar.String(n): 0x5E(16),str(32),0x5E(16),fVar(32),0(16),n(32),0x93(16),0x44(16),0x42(16)

文字列オブジェクトv数
var=str.Int(): 5(16),0(16),var(32),5(16),0(16),str(32),0x46(16),0x83(16),0x19(16),1(16)
var=str.Length(): 5(16),0(16),var(32),5(16),0(16),str(32),0x68(16),0x19(16),1(16)
var=str.LengthByte(): 5(16),0(16),var(32),5(16),0(16),str(32),0x69(16),0x19(16),1(16)
var=str.Empty():5(16),0(16),var(32),5(16),0(16),str(32),0x46(16),0x86(16),0x19(16),1(16)
var=str.Find(str1): 5,0,var,5,0,str,0x46,0x41,str1num,0x8E,0x19,1
str1=str2.GetPart(index,length): 0x5E,str1,5,0,str2,0x46,0,index,0,length,0x8F,0x44,0x42
str.PushBack(char): 5,0,str,0,char,0x91
str.PopBack(): 5,0,str,0x92

配列オブジェクトv数
var.Alloc(): 
var.Realloc(val): 5,0,var,0,val(32),0(16),次元数=1(32),0x52(16)
var.Free(): 5,0,var,0x53
var1=var2.Numof(): 5,0,var1,5,var2,0,次元数=1(32),0x54,0x19,1
var1.Copy(i,var2,j,num): 5,0,var1,0,i,0x5E,var2,0,j,0,num,0x55,1
var.Fill(index,val,num):    5,0,var,    0,index,0,val,0,num,0x56,1
var[i].Fill(index,val,num); 5,0,var,0,i,0,index,0,val,0,num,0x56,1
var.PushBack(num): 5,0,var,0,num,0x84
var.PopBack(): 5,0,var,0x85
var1=var2.Empty(): 5,0,var1,5,0,var2,0x87,0x19,1
var.Erase(index): 5,0,var,0,index,0x88,1
var.Insert(index,val): 5,0,var,0,index,0,val,0x89
var.Sort(): 5,0,var,0(16),0=NULL?(32), 0x90

int定数
 0(16),value(32)

float定数
 0x40(16),value(32) // value: i386 float(4byte)形式

string定数
 0x41(16),strno(32) // STR0に格{された文字列

char定数
 int定数と同じ

メッセ`ジ
 0x59(16),msgno(32) // MSG0に格{された文字列

式

if
  if (制御式1) {真文1} else if (制御式2) {真文2} else {真文3}  

  制御式1,0x2d(16),制御式2のアドレス,真文1,0x2c(16),次の文のアドレス,
   制御式2,0x2d(16),真文3のアドレス,真文2,0x2c(16),次の文のアドレス, 真文3;

 0x2C(16),adr(32): o条件ジャンプ
 op,0x2D(16),adr(32): 条件ジャンプ(条件を氦郡丹胜い趣)

while
 while(制御式) { 文 }
   制御式,0x2d,次の文のアドレス,文,0x2c,文の先^アドレス

for
 for(初期O定;@A条件;再O定式) { 文 }
   初期O定,@A条件,0x2d,次の文のアドレス,0x2c,文のアドレス,
   再O定式,0x2c,@A条件のアドレス,文,0x2c,再O定式のアドレス

switch
 0x5F(16),no(32): 事例式がint型
 0x60(16),no(32): 事例式がstring型

  switch(分岐式) { case 事例式1: 文１; case 事例式2: 文2; default: 文3}
    分岐式(int): 0x5f(16),SWI0のインデクス,0x2c,次の文のアドレス,文1,文2,文3;
    分岐式(string): 0x60(16),SWI0のインデクス,0x2c,次の文のアドレス,文1,文2,文3;

break
  0x2c,アドレス  // o条件ジャンプで脱出

continue
  0x2c,アドレス  // o条件ジャンプで指定の鏊へ

return
  0x2f           // 返りがあるときはスタックから取り出す

goto
  0x2c,アドレス

jump
 jump シナリオv数
 0x41, "シナリオv数"のSTR0番号, 0x65,0x64

jumps
 TODO

assert
 assert(式): 式,0x41(16),strno1(32),0x41(16),strno2(32),0(16),5(16),0(16),0x6F(16)

  strno1: "式"
  strno2: "v数の名前"

シナリオコメント
ifdef
  TODO

v数呼び出し
  0x30(16),funcno(32)

   c=function():  5,0,var,0x30,funcno,0x19(16),1(16),
   function(): 0x30,funcno,1(16)
   function(arg1,arg2): arg1,arg2,0x30,funno,1(16)

配列添字演算子
   op1[op2][op3]: op1,op2,2(16),op3
  
   var[i]=val:  0x5E,var,0(16),i(32),0(16),val(32),0x19(16),1(16);
   var[i][j]=k: 0x5E,var,0(16),i(32),2(16),0(16),j(32),0(16),val(32),0x19(16),1(16);
   var[i][j][k]=l: 0x5E,var,0(16),i,2(16),0,j,2(16),0,k,0,val,0x19(16),1(16);

直接メンバ演算子
  TODO


後置分演算子
  var++: 0x8A(16),var
  var1=var2++: 5,0,var1,5,0,var2,0x29(16),2(16),0x2A(16),1(16),0x31(16),0x19(16),1(16)
  グロ`バル涫の龊
    gVar++: 4,0,gVar,0x29,2,0x2A,1,0x31,1

後置源分演算子
  var--: 0x8B(16),var
  var1=var2--: 5,0,var1,5,0,var2,0x29(16),2(16),0x2A(16),1(16),0x32(16),0x19(16),1(16)
  グロ`バル涫の龊
    gVar--: 4,0,gVar,0x29,2,0x2A,1,0x32,1

前置分演算子
  ++var: 0x8A(16),var
  var1=++var2: 5,0,var1,5,0,var2,0x29(16),0x31(16),0x02(16),0x19(16),1(16)
  グロ`バル涫の龊
    ++gVar: 4,0,gVar,0x29,0x31,1,1

前置p分演算子
  --var: 0x8B(16),var
  var1=--var2: 5,0,var1,5,0,var2,0x29(16),0x32(16),0x02(16),0x19(16),1(16)
  グロ`バル涫の龊
    --gVar: 4,0,gVar,0x29,0x32,1,1

アドレス
 TODO

正符号
  なにもしない

符号
  0x06(16) int型
  var1=-var2: 5,0,var1,0x5E,var2,6(16),0x19,0x01;

  0x35(16) float型
  var1=-var2: 5,0,var1,0x5E,var2,0x35(16),0x24,0x01;

a数
  0x08(16)
  var1=~var2: 5,0,var1,0x5E,var2,8(16),0x19,0x01;

否定
  0x07(16)
  var1=!var2; 5,0,var1,0x5E,var2,7(16),0x19,0x01;

キャスト
  int(int): なし
  int(float): 0x33
  int(bool): なし
  float(int): 0x34
  float(float): なし
  bool(int): なし
  bool(bool): なし

  var1=int(fVar1); 5,0,var1,0x5E,fVar1,0x33(16),0x19(16),1(16)
  fVar=float(var); 5,0,fVar,0x5E,var,0x34(16),0x24(16),1(16)

new
情笕〉
引数加v数マクロ
 TODO

\算
  0x0B: int型
    var1=var2*val: 5,0,var1,0x5E,var2,0,val,0x0B(16),0x19(16),1(16); 
  0x38: float型
    fvar1=fvar2*fval: 5,0,fvar1,0x5E,fvar2,0x40,fval,0x38(16),0x24(16),1(16)

除算
  0x0C: int型
   var1 = var2/val: 5,0,var1,0x5E,var2,0,val,0x0C(16),0x19(16),1(16); 
  0x39: float型
   fvar1 = fvar2/fval: 5,0,fvar1,0x5E,fvar2,0x40,fval,0x39(16),0x24(16),1(16)

余
  0x0D
   var1=var2%val: 5,0,var1,0x5E,var2,0,val,0x0D(16),0x19(16),1(16); 

出力Q
 TODO

加算
  0x09: int型
   op1,op2,9
   var1=var2+val: 5,0,var1,0x5E,var2,0(16),val,9(16),0x19(16),1(16);
  
  0x36: float型
   op1,op2,0x36
   fvar1=fvar2+fval: 5,0,fvar1,0x5E,fvar2,0x40,fval,0x36(16),0x24(16),1(16)
  
  0x43: string型
   str0=str1+"str": 0x5E,str0,5(16),0(16),str1,0x46(16),0x41(16),strno,0x43(16),0x44(16),0x42(16)

p算
  0x0A: int型
   op1,op2,0x0A
   var1=var2-val: 5,0,var1,0x5E,var2,0,val,0x0A(16),0x19(16),1(16); 

  0x37: float型
   op1,op2,0x0B
   fvar1=fvar2-val: 5,0,fvar1,0x5E,fvar2,0x40,val,0x37(16),0x24(16),1(16)

左シフト
  0x11: int型
   var1=var2<<val: 5,0,var1,0x5E,var2,0,val,0x11(16),0x19,1;
  
  float型の龊稀⒁坏int型にQした後、シフトして、再度float型にQ
   fvar1=fvar2<<val: 5,0,fvar1,0x5E,fvar2,0x33(16),0(16),val,0x11,0x34,0x24,1

右シフト
  0x12: 
   var1=var2>>val: 5,0,var1,0x5E,var2,0,val,0x12(16),0x19,1; 

小なり
  0x13: int型
  0x3A: float型
  0x70: string型
   op1<op2:  op1,op2,0x13

以下
  0x15: int型
  0x3C: float型
  0x72: string型
   op1<=op2: op1,op2,0x15

大なり
  0x14: int型
  0x3B: float型
  0x71: string型
   op1>op2:  op1,op2,0x14

以上
  0x16: int型
  0x3D: floar型
  0x73: int型
   op1>=op2: op1,op2,0x16

等
  0x18: int型
  0x3F: float型
  0x49: string型
   op1==op2: op1,op2,0x18

非等
  0x17: int型
  0x3E: float型
  0x48: string型
   op1!=op2: op1,op2,0x17

参照等
  0x7F:
   op1===op2: op1,op2,0x7F

参照非等
  0x80:
   op1!==op2: op1,op2,0x80

ビットe
  0x0E:
   op1&op2: op1,op2,0x0E
   var1=var2&val: 5,0,var1,0x5E,var2,0,val,0x0E(16),0x19,1;

ビット差
  0x10:
   op1^op2: op1,op2,0x10
   var1=var2^val: 5,0,var1,0x5e,var2,0,val,0x10(16),0x19,1;

ヒット和
  0x0F:
   op1|op2: op1,op2,0x0F
   var1=var2|val; 5,0,var1,0x5E,var2,0,val,0x0F(16),0x19,1;

eY合
   op1&&op2
   op1,0x2D,韦龊悉挝膜违ドレス,op2,0x2D,韦龊悉挝膜违ドレス,
    真の龊悉挝,0x2C,式の最後のアドレス,韦龊悉挝,0x19,1

   var3=var1&&var2; 5,0,var3,0x5E,var1,0x2D(16),adr(32),0x5E,var2,0x2D(16),adr(32),0(16),val=1(32),0x2C(16),adr(32),0(16),val=0(32),0x19,1

和Y合
   op1||op2
   op1,0x2E,真の龊悉挝膜违ドレス,op2,0x2E,真の龊悉挝膜违ドレス,
    韦龊悉挝,0x2C,式の最後のアドレス,真の龊悉挝,0x19,1

   var3=var1||var2; 5,0,var3,0x5E,var1,0x2E(16),adr(32),0x5E,var2,0x2E(16),adr(32),0(16),val=0,0x2C(16),adr(32),0(16),val=1,0x19,1

条件
  op1 ? op2 : op3
  op1,0x2D,op3のアドレス,op2,0x2C,式の最後のアドレス,op3,0x19,1
   var = (cond)?(op1):(op2); 5,0,var,(cond),0x2D,adr1,(op1),0x2C,adr2,(op2),0x19,1

代入
  0x05,0,var,op2,0x19,0x01: int型
    var1 = var2;   5(16),0(16),var1,0x5E,var2,0x19,0x01;

  0x05,0,var,op2,0x24,0x01: float型
    fvar = val:  5,0,fvar,0x40,val, 0x24(16), 1(16); //float表F

  0x05,0,var,op2,0x8d,0x19,0x01: bool型
    bVar = val; 5,0,bVar,0,val(32),0x8D(16),0x19(16),1(16)

  0x5e,var,0x41,strno,0x44,0x42: String型
    var = "hoge"; 0x5E,var,0x41(16),strnum(32),0x44(16),0x42(16);

加算代入
  0x1A: int型
    var+=val: 5,0,var,0,val,0x1A,1
  0x25: float型
    fvar+=val: 5,0,fvar,0x40,val,0x25,1
  0x95: string型
    str+="str": 0x5e,str,0x41(16),strno,0x95(16),0x42(16)

p算代入
  0x1B: int型
    var-=val: 5,0,var,0,val,0x1B,1
  0x26: float型
    fvar-=fval: 5,0,fvar,0x40,fval,0x26,1

\算代入
  0x1C: int型
    var*=val: 5,0,var,0,val,0x1C,1
  0x27: float型
    fvar*=fval: 5,0,fvar,0x40,fval,0x27,1

除算代入
  0x1D: int型
    var/=val: 5,0,var,0,val,0x1D,1
  0x28: float型
    fvar/=fval: 5,0,fvar,0x40,fval,0x28,1

余代入
  0x1E: int型
    var%=val: 5,0,var,0,val,0x1E,1

左シフト代入
  0x22
    var1<<=val: 5,0,var1,0,val,0x22,1

右シフト代入
  0x23
    var1<<=val: 5,0,var1,0,val,0x23,1

ビットe代入
  0x1F
    var1&=val: 5,0,var1,0,val,0x1F,1

ビット差代入
  0x21
    var1^=val; 5,0,var1,0,val,0x21(16),1(16);

ビット和代入
  0x20
    var1|=val; 5,0,var1,0,val,0x20(16),1(16);

参照代入
 TODO

スワップ(???)
  0x96:
  var1<=>var2; 5,0,var1,5,0,var2,0(16),0x0A(16),0(16),0x96(16)

次
 TODO

mainv数
 MAINタグにmainv数のv数番号がかれている

messagev数
 MSGFタグにmessagev数のv数番号がかれている

onjumpv数
 OJMPタグにonjumpv数のv数番号がかかれている

System.XXXv数
 0x63,funcnum

   Exit: 0x00
   Reset: 0x05
   IsDebugMode: 0x11
   GlobalSave: 0x01
   GlobalLoad: 0x02
   ResumeSave: 0x08
   ResumeLoad: 0x09
   LockPeek: 0x03
   UnlockPeek: 0x04
   Peek: 0x14
   Sleep: 0x15
   Output: 0x06
   MsgBox: 0x07
   MsgBoxOkCancel: 0x12
   Error: 0x0F
   ExistFile: 0x0A
   ExistSaveFile: 0x10
   OpenWeb: 0x0B
   GetSaveFolderName: 0x0C
   GetGameName: 0x0E
   GetTime: 0x0D
   GetFuncStackName: 0x13

